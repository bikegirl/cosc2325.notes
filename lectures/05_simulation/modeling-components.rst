Modeling Components
###################

..  include::   /references.inc
..  _Power:     https://en.wikipedia.org/wiki/Electric_power

We will build basic components for our machine, using C++ class structures.
Each component will have a very simple internal structure. There will be very
few internal attributes in our class, and only a few methods. What will
surprise you, especially since you probably have not seen this style of
programming, is that we will not be building a traditional program at all.
There will be none of this "one object calls another object" stuff. Instead we
will set up a time simulation loop, and then loop over all components asking
each component to do a bit of work, every time we call it!  Control will pass
to the component method for some time, it will do its work, then simply return
to the time loop. It will return nothing (unless we want to trap some kind of
fault condition). The objects representing our components will not be calling
other objects. Instead, they will do a bit of internal work, saving the result
somewhere internally, where it could be later passed to a wire, and that is it!

This is exactly how real computers work. Each component has a set of input
signals, and internal structure of some kind, and produces a set of output
signals. That component has no idea that there are other components in the
system, it simple reacts to the input signals.

Signals Revisited
*****************

We are going to model the passing of signals along wires and through components
at certain moments in time. Every component, and wire for that matter, will
delay those signals by some small amount of time as they move along. It would be
interesting to track this delay so we can see how "fast" we can get signals
moved into place for the next cycle. It would also be neat if we could track
the amount of electrical power needed for each component to do its internal
job. Obviously, we do not have a real way to do this in our simulation, but we
could guess how much power was consumed based on the amount of code it takes to
do the internal work. We might also be able to model the heat generated by a
component by how much work is done together with how long it took to get the
job done. (Look up the definition of power_).

Hey, we are experimenting here. Maybe we are onto an idea that will be very
interesting to examine as our machine evolves!

To track all of this, we need to make our signals track power, heat, and time.
We can do this if our signal is not a simple integer, but an object that wraps
up the integer, along with some measure of the other aspects we want to tracl.
Sounds like the signal needs to be another object in our code!

Think More Than You Code
************************

You should note that I am describing an idea for a simulator, without showing
much (any) code In serious software development, the current thinking is that
up to 80% of your time should be spent thinking about what you want your code
to do, and the other 20% is spent actually crafting code. That sure flies in
the face of one view that coders simply pound on a keyboard until, magically,
everything just works.

I capture my thinking by writing down my thoughts. (That is where these
lecture notes come from). I am explaining (to myself, or to my students) what I
plan to do, and why. Those thoughts may make it into code, or I may come up
with a better idea that kills off an initial concept. Welcome to how
programming really works! In the end, my notes get transformed into
documentation for the project! I actually write much of mu documentation before
I write a line of code!

The Timing Loop
***************

Our system depends on a clock signal to keep things moving along. A computer is
not a system in continuous motion. (Such an electonic system would be called
"analog" in that case). Instead, it can be viewed as one where a clock signal
comes along, and a lot of action happens all at once. After a short amount of
time, (hopefully before the next clock signal happens), all internal processing
ceases. The signals arrive at a stable state, and we wait for another clock
signal to come along. 

Viewed that way, our simulator can trigger all needed action in a simple loop.
One tick of the clock begins processing. The combinational parts will not do
any work until a new signal reaches their inputs. A sequential component will
copy the waiting register value to the output side where the output processing
happens. The results of that processing will be transferred to the output
points on the component, and any waiting combinational parts will then see new
data to process. 

How Components Hook Together
============================

The interconnections between components gets very messy in real digital
circuits. Unlike our program code, things just do not happen in a precise, well
defined order. Let's start off looking at this by building a simple simulation
of a circuit that should give us a clock signal.

..  circuits::
    :align: center
    :tikzopts: circuit logic US
    :tikzlibs: circuits.logic.US,calc
    :width: 600

    \node at (0,0) (a) {IN};
    \node[not gate] at (1,0) (s1) {s1};
    \node[not gate] at (3,0) (s2) {s2};
    \node[not gate] at (5,0) (s3) {s3};
    \node at (7,0) (b) {OUT};
    
    \draw (a) -- (s1.input);
    \draw (s1.output) -- (s2.input);
    \draw (s2.output) -- (s3.input);
    \draw (s3.output) -- (b);
    \draw (6,0) -- (6,1.5);
    \draw (6,1.5) -- (0.5,1.5);
    \draw( 0.5,1.5) -- (0.5,0);

How are we going to simulate this circuit.?

..  note::

    In this circuit there is no clock signal, but we will still use a loop to
    simulate the passing of time. We will simply assime that a signal starts at the
    input point and flows through the circuit along the loop.

Here is a start:

Wires
=====

We can create simple wires like this:

..  literalinclude:: code/Wire.h
    :linenos:



Figuring out how to make that work in our simulator gets complicated. Suppose
we have several combinational parts in a series. The signals will need to
travel through all of them until we hit a sequential component where things
will stall again. If we know how the components are interconnected with wires,
we could conceivably follow that path and activate all the combinational
components as needed. 

We could deal with this flow through multiple components another way. Create an
inner loop over all combinational parts and check to see if any input values
have changed (the result of some other component generating a new output. As
long as this loop produces new data, we keep looping, but only those components
with new input data will do any work. When we see no changes, we stop. 

Setting Up the Loops
====================

Our simulator will be required to examine all components in the system each
time our clock "ticks". Each component will examine the input lines. If the
input has changed, there is work to do. The combinational logic attached to the
input will be activated and the result generated. For combinational components,
that new change is registers at the output point.  

Start With Signals
******************

We have to start somewhere, let's start off by creating a simple Signal class:

..  literalinclude::    code/Signal.h
    :linenos:

Not much exciting here. 

At this stage in development I m not going to clutter my Signal class with all
of my ideas. (This is another good reason to keep notes as you develop. All of
your ideas should not be added to the project at once!)

In keeping with the "Baby Steps" approach to software development, I start off
with the minimum amount of code needed to crate a signal. In my current concept
for the simulator, all I need is a simple integer to represent a digital value
being transferred along a wire, and a way to tell the wire to update that
value, or deliver it on demand.

Signal Timing
=============

We need to start thinking about how we are going to model the movement of
signals in this system.

The simulator design we will build will be made up of a number of parts falling
into two categories:

    * Digital Components - either combinational or sequential
    * Wires - that pass our signals between components

These parts will be asked to do some work under the supervision of a timing
loop.

Timing Loop
===========

In our system, signals will move around in simple cycle. 

Beginning at the output point of a component, a signal is placed on a wire and
travels to attached components at the other end (there may be more than one).
There will be a small delay as this happens, depending on the length of the
wire it travels along.

As the signal arrives at the next component, it will be passed through the
input combinational logic which may alter the signal. In combinational
components, after that processing, the signal arrives at the output point,
completing the cycle.

However, in sequential components, the processed input signal arrives at the
input side of the internal register boundary and hangs there. Nothing new
happens on the output side of these components until a synchronizing signal,
like the clock, arrives to trigger the data transfer to the output side. Only
after that happens does the signal continue on towards the final output point.
Again, it may pass through combinational logic to alter things. Once the signal
arrives at the output point, the cycle is complete for these components.

Since it actually takes time to get the signals through this cycle, we can
describe this cycle as follows:

    * t0: write component outputs to a wire
    * t1 ( = t0 + :math:`{\delta}t_{wire}`): signal arrives at component input
    * t2 ( = t1 + :math:`{\delta}t_{i_comb}`): signal leaves input combinational logic
    * t3: clock signal arrives, signal is copied over the internal barrier
    * t4: ( = ts +:math:`{\delta}t_{o_comb}`): signal leaves output combinational logic

..  note::

    It should be obvious that we cannot allow the clock signal to happen before
    the incoming signal makes it to the internal boundary. Otherwise, we will not
    be able to define what value is passed over the barrier! Over-clockers beware!

Micro-Cycles
------------

Viewed this way, we see that a single "tick" of the system clock may trigger a
sequence of small actions needed to effect a change in the value of signals in
the system. In complex computer systems, these internal steps are actually
controlled using something called "Micro-Operations" or "mu=ops". A single
instruction, available to an assembly language programmer, is actually
implemented as a sort of call to a subroutine, where a lower level language is
at work. The Pentium is actually constructed this way. 

..  note::

    That means that even if you thought assembly language was as close as we
    can get to hardware, there may be another language closer yet! Yikes!

Our Timing Loop
===============

We can implement our timing loop based on this analysis as follows:

    1. Loop over all components and have them copy their current outputs to attached wires. Then we loop over those components again, this time reading the inputs and passing the signals through the input combinational logic code. For combinational logic, the results of that processing will be copied to a holding place ready for the next output.

For sequential components, we send the clock signal to all of those, and pass the current register contents over the barrier. They will them be processed before ending up at the output holding point. 

That means we need to place a "register at the outputs of each component, which will hold the output value until needed. It also means that we need to loop over the components twice: once to start the cycle, and once when the clock arrives. 
    2. Have each component do internal work representing the internal logic that processes those inputs in that part
    3. Prepare the 

Enabling Components
-------------------

We run into one significant issue right away. SHould every component in the
system be allowed to do something on every tick of our clock? Well, in the
grand scheme of system simulation, that should be possible, and we certainly
could build our model thta way. However, to move from our basic understanding
of how our processor works, to something that complex would be very hard to
understand. So, we will not do that.

Instead, we will give every component a special "enable" signal line that tells
it to pay attention to what is going on, of jst sleep and do nothing (not even
respond to attempts to read signals coming from it.

..  note::

    In real electrical devices we call such an output source "tri-stated",
    meaning it acts like it is electrically disconnected from the wire.  

Signals pass between components. In a real computer, those signals travel along
wires that run from one component to another one. It is important that only one
component write a signal onto a wire, but multiple components can read from a
wire.  (There is a practical limit on how many can read, but we will not be
worrying about that for now.)

We can break those incoming and outgoing sets of signals into two parts. There
are signals carying data to the component (usually in the form of binary data.
The bits arrive over a set of parallel signal paths , all at once. The other
group of incoming signals are control signals that may modify the actions
inside the component. These signals do not necissarily arrive at the component
at the same time the data signals arrive.

On the outgoing side, again, the signals fall into two groups. There are data
signals produced by the actions inside the component, and status signals used
to describe theose results in some way. 

Component Class Files
*********************

To get started in this simulation program, let's create two basic classes, one
for the combinational components, and one for the sequential components.

Combinational Component
=======================

